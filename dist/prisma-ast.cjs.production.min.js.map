{"version":3,"file":"prisma-ast.cjs.production.min.js","sources":["../src/lexer.ts","../src/parser.ts","../src/visitor.ts","../src/getSchema.ts","../src/schemaSorter.ts","../src/printSchema.ts","../src/PrismaSchemaBuilder.ts"],"sourcesContent":["import { createToken, Lexer, IMultiModeLexerDefinition } from 'chevrotain';\n\nexport const Identifier = createToken({\n  name: 'Identifier',\n  pattern: /[a-zA-Z]\\w*/,\n});\nexport const Datasource = createToken({\n  name: 'Datasource',\n  pattern: /datasource/,\n  push_mode: 'block',\n});\nexport const Generator = createToken({\n  name: 'Generator',\n  pattern: /generator/,\n  push_mode: 'block',\n});\nexport const Model = createToken({\n  name: 'Model',\n  pattern: /model/,\n  push_mode: 'block',\n});\nexport const Enum = createToken({\n  name: 'Enum',\n  pattern: /enum/,\n  push_mode: 'block',\n});\nexport const True = createToken({\n  name: 'True',\n  pattern: /true/,\n  longer_alt: Identifier,\n});\nexport const False = createToken({\n  name: 'False',\n  pattern: /false/,\n  longer_alt: Identifier,\n});\nexport const Null = createToken({\n  name: 'Null',\n  pattern: /null/,\n  longer_alt: Identifier,\n});\nexport const Comment = createToken({\n  name: 'Comment',\n  pattern: Lexer.NA,\n});\n\nexport const DocComment = createToken({\n  name: 'DocComment',\n  pattern: /\\/\\/\\/\\s*(.+)/,\n  categories: [Comment],\n});\nexport const LineComment = createToken({\n  name: 'LineComment',\n  pattern: /\\/\\/\\s*(.+)/,\n  categories: [Comment],\n});\nexport const Attribute = createToken({\n  name: 'Attribute',\n  pattern: Lexer.NA,\n});\nexport const ModelAttribute = createToken({\n  name: 'ModelAttribute',\n  pattern: /@@/,\n  label: \"'@@'\",\n  categories: [Attribute],\n});\nexport const FieldAttribute = createToken({\n  name: 'FieldAttribute',\n  pattern: /@/,\n  label: \"'@'\",\n  categories: [Attribute],\n});\nexport const Dot = createToken({\n  name: 'Dot',\n  pattern: /\\./,\n  label: \"'.'\",\n});\nexport const QuestionMark = createToken({\n  name: 'QuestionMark',\n  pattern: /\\?/,\n  label: \"'?'\",\n});\nexport const LCurly = createToken({\n  name: 'LCurly',\n  pattern: /{/,\n  label: \"'{'\",\n});\nexport const RCurly = createToken({\n  name: 'RCurly',\n  pattern: /}/,\n  label: \"'}'\",\n  pop_mode: true,\n});\nexport const LRound = createToken({\n  name: 'LRound',\n  pattern: /\\(/,\n  label: \"'('\",\n});\nexport const RRound = createToken({\n  name: 'RRound',\n  pattern: /\\)/,\n  label: \"')'\",\n});\nexport const LSquare = createToken({\n  name: 'LSquare',\n  pattern: /\\[/,\n  label: \"'['\",\n});\nexport const RSquare = createToken({\n  name: 'RSquare',\n  pattern: /\\]/,\n  label: \"']'\",\n});\nexport const Comma = createToken({\n  name: 'Comma',\n  pattern: /,/,\n  label: \"','\",\n});\nexport const Colon = createToken({\n  name: 'Colon',\n  pattern: /:/,\n  label: \"':'\",\n});\nexport const Equals = createToken({\n  name: 'Equals',\n  pattern: /=/,\n  label: \"'='\",\n});\nexport const StringLiteral = createToken({\n  name: 'StringLiteral',\n  pattern: /\"(:?[^\\\\\"\\n\\r]|\\\\(:?[bfnrtv\"\\\\/]|u[0-9a-fA-F]{4}))*\"/,\n});\nexport const NumberLiteral = createToken({\n  name: 'NumberLiteral',\n  pattern: /-?(0|[1-9]\\d*)(\\.\\d+)?([eE][+-]?\\d+)?/,\n});\nexport const WhiteSpace = createToken({\n  name: 'WhiteSpace',\n  pattern: /\\s+/,\n  group: Lexer.SKIPPED,\n});\nexport const LineBreak = createToken({\n  name: 'LineBreak',\n  pattern: /\\n|\\r\\n/,\n  line_breaks: true,\n  label: 'LineBreak',\n});\n\nconst naTokens = [Comment, DocComment, LineComment, LineBreak, WhiteSpace];\n\nexport const multiModeTokens: IMultiModeLexerDefinition = {\n  modes: {\n    global: [...naTokens, Datasource, Generator, Model, Enum],\n    block: [\n      ...naTokens,\n      Attribute,\n      ModelAttribute,\n      FieldAttribute,\n      Dot,\n      QuestionMark,\n      LCurly,\n      RCurly,\n      LSquare,\n      RSquare,\n      LRound,\n      RRound,\n      Comma,\n      Colon,\n      Equals,\n      True,\n      False,\n      Null,\n      StringLiteral,\n      NumberLiteral,\n      Identifier,\n    ],\n  },\n  defaultMode: 'global',\n};\n\nexport const PrismaLexer = new Lexer(multiModeTokens);\n","import { CstParser } from 'chevrotain';\nimport * as lexer from './lexer';\n\ntype ComponentType = 'datasource' | 'generator' | 'model' | 'enum';\nexport class PrismaParser extends CstParser {\n  constructor() {\n    super(lexer.multiModeTokens);\n    this.performSelfAnalysis();\n  }\n\n  private break = this.RULE('break', () => {\n    this.CONSUME1(lexer.LineBreak);\n    this.CONSUME2(lexer.LineBreak);\n  });\n\n  private keyedArg = this.RULE('keyedArg', () => {\n    this.CONSUME(lexer.Identifier, { LABEL: 'keyName' });\n    this.CONSUME(lexer.Colon);\n    this.SUBRULE(this.value);\n  });\n\n  private array = this.RULE('array', () => {\n    this.CONSUME(lexer.LSquare);\n    this.MANY_SEP({\n      SEP: lexer.Comma,\n      DEF: () => {\n        this.SUBRULE(this.value);\n      },\n    });\n    this.CONSUME(lexer.RSquare);\n  });\n\n  private func = this.RULE('func', () => {\n    this.CONSUME(lexer.Identifier, { LABEL: 'funcName' });\n    this.CONSUME(lexer.LRound);\n    this.MANY_SEP({\n      SEP: lexer.Comma,\n      DEF: () => {\n        this.OR([\n          { ALT: () => this.SUBRULE(this.keyedArg) },\n          { ALT: () => this.SUBRULE(this.value) },\n        ]);\n      },\n    });\n    this.CONSUME(lexer.RRound);\n  });\n\n  private value = this.RULE('value', () => {\n    this.OR([\n      { ALT: () => this.CONSUME(lexer.StringLiteral, { LABEL: 'value' }) },\n      { ALT: () => this.CONSUME(lexer.NumberLiteral, { LABEL: 'value' }) },\n      { ALT: () => this.SUBRULE(this.array, { LABEL: 'value' }) },\n      { ALT: () => this.SUBRULE(this.func, { LABEL: 'value' }) },\n      { ALT: () => this.CONSUME(lexer.True, { LABEL: 'value' }) },\n      { ALT: () => this.CONSUME(lexer.False, { LABEL: 'value' }) },\n      { ALT: () => this.CONSUME(lexer.Null, { LABEL: 'value' }) },\n      { ALT: () => this.CONSUME(lexer.Identifier, { LABEL: 'value' }) },\n    ]);\n  });\n\n  private property = this.RULE('property', () => {\n    this.CONSUME(lexer.Identifier, { LABEL: 'propertyName' });\n    this.CONSUME(lexer.Equals);\n    this.SUBRULE(this.value, { LABEL: 'propertyValue' });\n  });\n\n  private assignment = this.RULE('assignment', () => {\n    this.CONSUME(lexer.Identifier, { LABEL: 'assignmentName' });\n    this.CONSUME(lexer.Equals);\n    this.SUBRULE(this.value, { LABEL: 'assignmentValue' });\n  });\n\n  private field = this.RULE('field', () => {\n    this.CONSUME(lexer.Identifier, { LABEL: 'fieldName' });\n    this.SUBRULE(this.value, { LABEL: 'fieldType' });\n    this.OPTION1(() => {\n      this.OR([\n        {\n          ALT: () => {\n            this.CONSUME(lexer.LSquare, { LABEL: 'array' });\n            this.CONSUME(lexer.RSquare, { LABEL: 'array' });\n          },\n        },\n        { ALT: () => this.CONSUME(lexer.QuestionMark, { LABEL: 'optional' }) },\n      ]);\n    });\n    this.MANY(() => {\n      this.SUBRULE(this.attribute, { LABEL: 'attributeList' });\n    });\n    this.OPTION2(() => {\n      this.CONSUME(lexer.Comment, { LABEL: 'comment' });\n    });\n  });\n\n  private block = this.RULE(\n    'block',\n    (\n      options: {\n        componentType?: ComponentType;\n      } = {}\n    ) => {\n      const { componentType } = options;\n      const isEnum = componentType === 'enum';\n      const isModel = componentType === 'model';\n\n      this.CONSUME(lexer.LCurly);\n      this.CONSUME1(lexer.LineBreak);\n      this.MANY(() => {\n        this.OR([\n          { ALT: () => this.SUBRULE(this.comment, { LABEL: 'list' }) },\n          {\n            GATE: () => isModel,\n            ALT: () => this.SUBRULE(this.property, { LABEL: 'list' }),\n          },\n          { ALT: () => this.SUBRULE(this.attribute, { LABEL: 'list' }) },\n          {\n            GATE: () => isModel,\n            ALT: () => this.SUBRULE(this.field, { LABEL: 'list' }),\n          },\n          {\n            GATE: () => isEnum,\n            ALT: () => this.SUBRULE(this.enum, { LABEL: 'list' }),\n          },\n          {\n            GATE: () => !isModel,\n            ALT: () => this.SUBRULE(this.assignment, { LABEL: 'list' }),\n          },\n          { ALT: () => this.SUBRULE(this.break, { LABEL: 'list' }) },\n          { ALT: () => this.CONSUME2(lexer.LineBreak) },\n        ]);\n      });\n      this.CONSUME(lexer.RCurly);\n    }\n  );\n\n  private enum = this.RULE('enum', () => {\n    this.CONSUME(lexer.Identifier, { LABEL: 'enumName' });\n    this.OPTION(() => {\n      this.CONSUME(lexer.Comment, { LABEL: 'comment' });\n    });\n  });\n  private attribute = this.RULE('attribute', () => {\n    this.OR1([\n      {\n        ALT: () =>\n          this.CONSUME(lexer.ModelAttribute, { LABEL: 'modelAttribute' }),\n      },\n      {\n        ALT: () =>\n          this.CONSUME(lexer.FieldAttribute, { LABEL: 'fieldAttribute' }),\n      },\n    ]);\n    this.OR2([\n      {\n        ALT: () => {\n          this.CONSUME1(lexer.Identifier, { LABEL: 'groupName' });\n          this.CONSUME(lexer.Dot);\n          this.CONSUME2(lexer.Identifier, { LABEL: 'attributeName' });\n        },\n      },\n      {\n        ALT: () => this.CONSUME(lexer.Identifier, { LABEL: 'attributeName' }),\n      },\n    ]);\n\n    this.OPTION(() => {\n      this.CONSUME(lexer.LRound);\n      this.MANY_SEP({\n        SEP: lexer.Comma,\n        DEF: () => {\n          this.SUBRULE(this.attributeArg);\n        },\n      });\n      this.CONSUME(lexer.RRound);\n    });\n  });\n\n  private attributeArg = this.RULE('attributeArg', () => {\n    this.OR([\n      {\n        ALT: () => this.SUBRULE(this.keyedArg, { LABEL: 'value' }),\n      },\n      {\n        ALT: () => this.SUBRULE(this.value, { LABEL: 'value' }),\n      },\n    ]);\n  });\n\n  private component = this.RULE('component', () => {\n    const type = this.OR1([\n      { ALT: () => this.CONSUME(lexer.Datasource, { LABEL: 'type' }) },\n      { ALT: () => this.CONSUME(lexer.Generator, { LABEL: 'type' }) },\n      { ALT: () => this.CONSUME(lexer.Model, { LABEL: 'type' }) },\n      { ALT: () => this.CONSUME(lexer.Enum, { LABEL: 'type' }) },\n    ]);\n    this.OR2([\n      {\n        ALT: () => {\n          this.CONSUME1(lexer.Identifier, { LABEL: 'groupName' });\n          this.CONSUME(lexer.Dot);\n          this.CONSUME2(lexer.Identifier, { LABEL: 'componentName' });\n        },\n      },\n      {\n        ALT: () => this.CONSUME(lexer.Identifier, { LABEL: 'componentName' }),\n      },\n    ]);\n\n    this.SUBRULE(this.block, {\n      ARGS: [{ componentType: type.image as ComponentType }],\n    });\n  });\n\n  private comment = this.RULE('comment', () => {\n    this.CONSUME(lexer.Comment, { LABEL: 'text' });\n  });\n\n  public schema = this.RULE('schema', () => {\n    this.MANY(() => {\n      this.OR([\n        { ALT: () => this.SUBRULE(this.comment, { LABEL: 'list' }) },\n        { ALT: () => this.SUBRULE(this.component, { LABEL: 'list' }) },\n        { ALT: () => this.SUBRULE(this.break, { LABEL: 'list' }) },\n        { ALT: () => this.CONSUME(lexer.LineBreak) },\n      ]);\n    });\n  });\n}\n\nexport const parser = new PrismaParser();\n","import { CstNode, IToken } from '@chevrotain/types';\nimport { parser } from './parser';\nimport * as Types from './getSchema';\n\nconst BasePrismaVisitor = parser.getBaseCstVisitorConstructorWithDefaults();\nexport class PrismaVisitor extends BasePrismaVisitor {\n  constructor() {\n    super();\n    this.validateVisitor();\n  }\n\n  schema(ctx: CstNode & { list: CstNode[] }): Types.Schema {\n    const list = ctx.list?.map(item => this.visit([item])) || [];\n    return { type: 'schema', list };\n  }\n\n  component(\n    ctx: CstNode & {\n      type: [IToken];\n      componentName: [IToken];\n      block: [CstNode];\n    }\n  ): Types.Block {\n    const [{ image: type }] = ctx.type;\n    const [{ image: name }] = ctx.componentName;\n    const list = this.visit(ctx.block);\n\n    switch (type) {\n      case 'datasource':\n        return { type: 'datasource', name, assignments: list };\n      case 'generator':\n        return { type: 'generator', name, assignments: list };\n      case 'model':\n        return { type: 'model', name, properties: list };\n      case 'enum':\n        return { type: 'enum', name, enumerators: list };\n      default:\n        throw new Error(`Unexpected block type: ${type}`);\n    }\n  }\n\n  break(): Types.Break {\n    return { type: 'break' };\n  }\n\n  comment(ctx: CstNode & { text: [IToken] }): Types.Comment {\n    const [{ image: comment }] = ctx.text;\n    return { type: 'comment', text: comment };\n  }\n\n  block(ctx: CstNode & { list: CstNode[] }): Types.Block[] {\n    return ctx.list?.map(item => this.visit([item]));\n  }\n\n  assignment(\n    ctx: CstNode & { assignmentName: [IToken]; assignmentValue: [CstNode] }\n  ): Types.Assignment {\n    const value = this.visit(ctx.assignmentValue);\n    const [{ image: key }] = ctx.assignmentName;\n    return { type: 'assignment', key, value };\n  }\n\n  field(\n    ctx: CstNode & {\n      fieldName: [IToken];\n      fieldType: [CstNode];\n      array: [IToken];\n      optional: [IToken];\n      attributeList: CstNode[];\n      comment: [IToken];\n    }\n  ): Types.Field {\n    const fieldType = this.visit(ctx.fieldType);\n    const [{ image: name }] = ctx.fieldName;\n    const attributes =\n      ctx.attributeList && ctx.attributeList.map(item => this.visit([item]));\n    const comment = ctx.comment?.[0]?.image;\n    return {\n      type: 'field',\n      name,\n      fieldType,\n      array: ctx.array != null,\n      optional: ctx.optional != null,\n      attributes,\n      comment,\n    };\n  }\n\n  attribute(\n    ctx: CstNode & {\n      modelAttribute: [IToken];\n      fieldAttribute: [IToken];\n      groupName: [IToken];\n      attributeName: [IToken];\n      attributeArg: CstNode[];\n    }\n  ): Types.Attr {\n    const [{ image: name }] = ctx.attributeName;\n    const [{ image: group }] = ctx.groupName || [{}];\n    const args =\n      ctx.attributeArg && ctx.attributeArg.map(attr => this.visit(attr));\n    const kind = ctx.modelAttribute != null ? 'model' : 'field';\n\n    return { type: 'attribute', name, kind, group, args };\n  }\n\n  attributeArg(ctx: CstNode & { value: [CstNode] }): Types.AttributeArgument {\n    const value = this.visit(ctx.value);\n    return { type: 'attributeArgument', value };\n  }\n\n  func(ctx: CstNode & { funcName: [IToken]; value: CstNode[]; keyedArg: CstNode[] }): Types.Func {\n    const [{ image: name }] = ctx.funcName;\n    const params = ctx.value && ctx.value.map(item => this.visit([item]));\n    const keyedParams = ctx.keyedArg && ctx.keyedArg.map(item => this.visit([item]));\n    const pars = (params || keyedParams) && [...(params ?? []), ...(keyedParams ?? [])];\n    return { type: 'function', name, params: pars };\n  }\n\n  array(ctx: CstNode & { value: CstNode[] }): Types.RelationArray {\n    const args = ctx.value && ctx.value.map(item => this.visit([item]));\n    return { type: 'array', args };\n  }\n\n  keyedArg(\n    ctx: CstNode & { keyName: [IToken]; value: [CstNode] }\n  ): Types.KeyValue {\n    const [{ image: key }] = ctx.keyName;\n    const value = this.visit(ctx.value);\n    return { type: 'keyValue', key, value };\n  }\n\n  value(ctx: CstNode & { value: [IToken] | [CstNode] }): Types.Value {\n    if (isToken(ctx.value)) {\n      const [{ image }] = ctx.value;\n      return image;\n    }\n    return this.visit(ctx.value);\n  }\n\n  enum(\n    ctx: CstNode & { enumName: [IToken]; comment: [IToken] }\n  ): Types.Enumerator {\n    const [{ image: name }] = ctx.enumName;\n    const comment = ctx.comment?.[0]?.image;\n    return { type: 'enumerator', name, comment };\n  }\n}\n\nfunction isToken(node: [IToken] | [CstNode]): node is [IToken] {\n  return 'image' in node[0];\n}\n","import { PrismaLexer } from './lexer';\nimport { PrismaVisitor } from './visitor';\nimport { parser } from './parser';\n\nexport function getSchema(source: string): Schema {\n  const lexingResult = PrismaLexer.tokenize(source);\n  parser.input = lexingResult.tokens;\n  const cstNode = parser.schema();\n  if (parser.errors.length > 0) throw parser.errors[0];\n  const visitor = new PrismaVisitor();\n  return visitor.visit(cstNode);\n}\n\nexport interface Schema {\n  type: 'schema';\n  list: Block[];\n}\n\nexport type Block = Model | Datasource | Generator | Enum | Comment | Break;\n\nexport interface Model {\n  type: 'model';\n  name: string;\n  properties: Array<Property | Comment | Break>;\n}\n\nexport interface Datasource {\n  type: 'datasource';\n  name: string;\n  assignments: Array<Assignment | Comment | Break>;\n}\n\nexport interface Generator {\n  type: 'generator';\n  name: string;\n  assignments: Array<Assignment | Comment | Break>;\n}\n\nexport interface Enum {\n  type: 'enum';\n  name: string;\n  enumerators: Array<Enumerator | Comment | Break>;\n}\n\nexport interface Comment {\n  type: 'comment';\n  text: string;\n}\n\nexport interface Break {\n  type: 'break';\n}\n\nexport type Property = GroupedModelAttribute | ModelAttribute | Field;\n\nexport interface Assignment {\n  type: 'assignment';\n  key: string;\n  value: Value;\n}\n\nexport interface Enumerator {\n  type: 'enumerator';\n  name: string;\n  value?: Value;\n  comment?: string;\n}\n\nexport interface ModelAttribute {\n  type: 'attribute';\n  kind: 'model';\n  group?: string;\n  name: string;\n  args: AttributeArgument[];\n}\n\nexport type GroupedModelAttribute = ModelAttribute & { group: string };\n\nexport interface Field {\n  type: 'field';\n  name: string;\n  fieldType: string | Func;\n  array?: boolean;\n  optional?: boolean;\n  attributes?: Attribute[];\n  comment?: string;\n}\n\nexport type Attr =\n  | Attribute\n  | GroupedAttribute\n  | ModelAttribute\n  | GroupedModelAttribute;\n\nexport interface Attribute {\n  type: 'attribute';\n  kind: 'field';\n  group?: string;\n  name: string;\n  args?: AttributeArgument[];\n}\n\nexport type GroupedAttribute = Attribute & { group: string };\n\nexport interface AttributeArgument {\n  type: 'attributeArgument';\n  value: KeyValue | Value | Func;\n}\n\nexport interface KeyValue {\n  type: 'keyValue';\n  key: string;\n  value: Value;\n}\n\nexport interface Func {\n  type: 'function';\n  name: string;\n  params: Value[];\n}\n\nexport interface RelationArray {\n  type: 'array';\n  args: string[];\n}\n\nexport type Value =\n  | string\n  | number\n  | boolean\n  | Func\n  | RelationArray\n  | Array<Value>;\n","import { Block, Schema } from './getSchema';\n\nconst unsorted = ['break', 'comment'];\nconst defaultSortOrder = [\n  'generator',\n  'datasource',\n  'model',\n  'enum',\n  'break',\n  'comment',\n];\n\nexport const schemaSorter = (\n  schema: Schema,\n  locales?: string | string[],\n  sortOrder: string[] = defaultSortOrder\n) => (a: Block, b: Block): number => {\n  // Preserve the position of comments and line breaks relative to their\n  // position in the file, since when a re-sort happens it wouldn't be\n  // clear whether a comment should affix to the object above or below it.\n  const aUnsorted = unsorted.indexOf(a.type) !== -1;\n  const bUnsorted = unsorted.indexOf(b.type) !== -1;\n\n  if (aUnsorted !== bUnsorted) {\n    return schema.list.indexOf(a) - schema.list.indexOf(b);\n  }\n\n  if (sortOrder !== defaultSortOrder)\n    sortOrder = sortOrder.concat(defaultSortOrder);\n  const typeIndex = sortOrder.indexOf(a.type) - sortOrder.indexOf(b.type);\n  if (typeIndex !== 0) return typeIndex;\n\n  // Resolve ties using the name of object's name.\n  if ('name' in a && 'name' in b) return a.name.localeCompare(b.name, locales);\n\n  // If all else fails, leave objects in their original position.\n  return 0;\n};\n","import * as Types from './getSchema';\nimport { EOL } from 'os';\nimport { schemaSorter } from './schemaSorter';\n\nexport interface PrintOptions {\n  sort?: boolean;\n  locales?: string | string[];\n  sortOrder?: Array<'generator' | 'datasource' | 'model' | 'enum'>;\n}\n\nexport function printSchema(\n  schema: Types.Schema,\n  options: PrintOptions = {}\n): string {\n  const { sort = false, locales = undefined, sortOrder = undefined } = options;\n  let blocks = schema.list;\n  if (sort) {\n    // no point in preserving line breaks when re-sorting\n    blocks = schema.list = blocks.filter(block => block.type !== 'break');\n    const sorter = schemaSorter(schema, locales, sortOrder);\n    blocks.sort(sorter);\n  }\n\n  return (\n    blocks\n      .map(printBlock)\n      .filter(Boolean)\n      .join(EOL)\n      .replace(/(\\r?\\n\\s*){3,}/g, EOL + EOL) + EOL\n  );\n}\n\nfunction printBlock(block: Types.Block): string {\n  switch (block.type) {\n    case 'comment':\n      return printComment(block);\n    case 'datasource':\n      return printDatasource(block);\n    case 'enum':\n      return printEnum(block);\n    case 'generator':\n      return printGenerator(block);\n    case 'model':\n      return printModel(block);\n    case 'break':\n      return printBreak();\n    default:\n      throw new Error(`Unrecognized block type`);\n  }\n}\n\nfunction printComment(comment: Types.Comment) {\n  return comment.text;\n}\n\nfunction printBreak() {\n  return EOL;\n}\n\nfunction printDatasource(db: Types.Datasource) {\n  const children = computeAssignmentFormatting(db.assignments);\n\n  return `\ndatasource ${db.name} {\n  ${children}\n}`;\n}\n\nfunction printEnum(enumerator: Types.Enum) {\n  const children = enumerator.enumerators\n    .map(printEnumerator)\n    .filter(Boolean)\n    .join(`${EOL}  `)\n    .replace(/(\\r?\\n\\s*){3,}/g, `${EOL + EOL}  `);\n\n  return `\nenum ${enumerator.name} {\n  ${children}\n}`;\n}\n\nfunction printEnumerator(\n  enumerator: Types.Enumerator | Types.Attribute | Types.Comment | Types.Break\n) {\n  switch (enumerator.type) {\n    case 'enumerator':\n      return [enumerator.name, enumerator.comment].filter(Boolean).join(' ');\n    case 'attribute':\n      return printAttribute(enumerator);\n    case 'comment':\n      return printComment(enumerator);\n    case 'break':\n      return printBreak();\n    default:\n      throw new Error(`Unexpected enumerator type`);\n  }\n}\n\nfunction printGenerator(generator: Types.Generator) {\n  const children = computeAssignmentFormatting(generator.assignments);\n\n  return `\ngenerator ${generator.name} {\n  ${children}\n}`;\n}\n\nfunction printModel(model: Types.Model) {\n  const children = computePropertyFormatting(model.properties);\n\n  return `\nmodel ${model.name} {\n  ${children}\n}`;\n}\n\nfunction printAssignment(\n  node: Types.Assignment | Types.Comment | Types.Break,\n  keyLength = 0\n) {\n  switch (node.type) {\n    case 'comment':\n      return printComment(node);\n    case 'break':\n      return printBreak();\n    case 'assignment':\n      return `${node.key.padEnd(keyLength)} = ${printValue(node.value)}`;\n    default:\n      throw new Error(`Unexpected assignment type`);\n  }\n}\n\nfunction printProperty(\n  node: Types.Property | Types.Comment | Types.Break,\n  nameLength = 0,\n  typeLength = 0\n) {\n  switch (node.type) {\n    case 'attribute':\n      return printAttribute(node);\n    case 'field':\n      return printField(node, nameLength, typeLength);\n    case 'comment':\n      return printComment(node);\n    case 'break':\n      return printBreak();\n    default:\n      throw new Error(`Unrecognized property type`);\n  }\n}\n\nfunction printAttribute(attribute: Types.Attribute | Types.ModelAttribute) {\n  const args =\n    attribute.args && attribute.args.length > 0\n      ? `(${attribute.args\n          .map(printAttributeArg)\n          .filter(Boolean)\n          .join(', ')})`\n      : '';\n\n  const name = [attribute.name];\n  if (attribute.group) name.unshift(attribute.group);\n\n  return `${attribute.kind === 'field' ? '@' : '@@'}${name.join('.')}${args}`;\n}\n\nfunction printAttributeArg(arg: Types.AttributeArgument) {\n  return printValue(arg.value);\n}\n\nfunction printField(field: Types.Field, nameLength = 0, typeLength = 0) {\n  const name = field.name.padEnd(nameLength);\n  const fieldType = printFieldType(field).padEnd(typeLength);\n  const attrs = field.attributes ? field.attributes.map(printAttribute) : [];\n  const comment = field.comment;\n  return (\n    [name, fieldType, ...attrs]\n      .filter(Boolean)\n      .join(' ')\n      // comments ignore indents\n      .trim() + (comment ? ` ${comment}` : '')\n  );\n}\n\nfunction printFieldType(field: Types.Field) {\n  const suffix = field.array ? '[]' : field.optional ? '?' : '';\n\n  if (typeof field.fieldType === 'object') {\n    switch (field.fieldType.type) {\n      case 'function': {\n        return `${printFunction(field.fieldType)}${suffix}`;\n      }\n      default:\n        throw new Error(`Unexpected field type`);\n    }\n  }\n\n  return `${field.fieldType}${suffix}`;\n}\n\nfunction printFunction(func: Types.Func) {\n  const params = func.params ? func.params.map(printValue) : '';\n  return `${func.name}(${params})`;\n}\n\nfunction printValue(value: Types.KeyValue | Types.Value): string {\n  switch (typeof value) {\n    case 'object': {\n      if ('type' in value) {\n        switch (value.type) {\n          case 'keyValue':\n            return `${value.key}: ${printValue(value.value)}`;\n          case 'function':\n            return printFunction(value);\n          case 'array':\n            return `[${\n              value.args != null ? value.args.map(printValue).join(', ') : ''\n            }]`;\n          default:\n            throw new Error(`Unexpected value type`);\n        }\n      }\n\n      throw new Error(`Unexpected object value`);\n    }\n    default:\n      return String(value);\n  }\n}\n\nfunction computeAssignmentFormatting(\n  list: Array<Types.Comment | Types.Break | Types.Assignment>\n) {\n  let pos = 0;\n  const listBlocks = list.reduce<Array<typeof list>>(\n    (memo, current, index, arr) => {\n      if (current.type === 'break') return memo;\n      if (index > 0 && arr[index - 1].type === 'break') memo[++pos] = [];\n      memo[pos].push(current);\n      return memo;\n    },\n    [[]]\n  );\n\n  const keyLengths = listBlocks.map(lists =>\n    lists.reduce(\n      (max, current) =>\n        Math.max(\n          max,\n          // perhaps someone more typescript-savy than I am can fix this\n          current.type === 'assignment' ? current.key.length : 0\n        ),\n      0\n    )\n  );\n\n  return list\n    .map((item, index, arr) => {\n      if (index > 0 && item.type !== 'break' && arr[index - 1].type === 'break')\n        keyLengths.shift();\n      return printAssignment(item, keyLengths[0]);\n    })\n    .filter(Boolean)\n    .join(`${EOL}  `)\n    .replace(/(\\r?\\n\\s*){3,}/g, `${EOL + EOL}  `);\n}\n\nfunction computePropertyFormatting(\n  list: Array<Types.Break | Types.Comment | Types.Property>\n) {\n  let pos = 0;\n  const listBlocks = list.reduce<Array<typeof list>>(\n    (memo, current, index, arr) => {\n      if (current.type === 'break') return memo;\n      if (index > 0 && arr[index - 1].type === 'break') memo[++pos] = [];\n      memo[pos].push(current);\n      return memo;\n    },\n    [[]]\n  );\n\n  const nameLengths = listBlocks.map(lists =>\n    lists.reduce(\n      (max, current) =>\n        Math.max(\n          max,\n          // perhaps someone more typescript-savy than I am can fix this\n          current.type === 'field' ? current.name.length : 0\n        ),\n      0\n    )\n  );\n\n  const typeLengths = listBlocks.map(lists =>\n    lists.reduce(\n      (max, current) =>\n        Math.max(\n          max,\n          // perhaps someone more typescript-savy than I am can fix this\n          current.type === 'field' ? printFieldType(current).length : 0\n        ),\n      0\n    )\n  );\n\n  return list\n    .map((prop, index, arr) => {\n      if (\n        index > 0 &&\n        prop.type !== 'break' &&\n        arr[index - 1].type === 'break'\n      ) {\n        nameLengths.shift();\n        typeLengths.shift();\n      }\n\n      return printProperty(prop, nameLengths[0], typeLengths[0]);\n    })\n    .filter(Boolean)\n    .join(`${EOL}  `)\n    .replace(/(\\r?\\n\\s*){3,}/g, `${EOL + EOL}  `);\n}\n","import * as schema from './getSchema';\nimport { PrintOptions, printSchema } from './printSchema';\n\n/** Returns the function type Original with its return type changed to NewReturn. */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype ReplaceReturnType<Original extends (...args: any) => any, NewReturn> = (\n  ...a: Parameters<Original>\n) => NewReturn;\n\n/**\n * Methods with return values that do not propagate the builder should not have\n * their return value modified by the type replacement system below\n * */\ntype ExtractKeys = 'getSchema' | 'getSubject' | 'getParent' | 'print';\n\n/** These keys preserve the return value context that they were given */\ntype NeutralKeys = 'break' | 'comment' | 'attribute' | 'enumerator';\n\n/** Keys allowed when you call .datasource() or .generator() */\ntype DatasourceOrGeneratorKeys = 'assignment';\n\n/** Keys allowed when you call .enum(\"name\") */\ntype EnumKeys = 'enumerator';\n\n/** Keys allowed when you call .field(\"name\") */\ntype FieldKeys = 'attribute';\n\n/** Keys allowed when you call .model(\"name\") */\ntype ModelKeys = 'blockAttribute' | 'field';\n\n/**\n * Utility type for making the PrismaSchemaBuilder below readable:\n * Removes methods from the builder that are prohibited based on the context\n * the builder is in. For example, you can add fields to a model, but you can't\n * add fields to an enum or a datasource.\n */\ntype PrismaSchemaSubset<\n  Universe extends keyof ConcretePrismaSchemaBuilder,\n  Method\n> = ReplaceReturnType<\n  ConcretePrismaSchemaBuilder[Universe],\n  PrismaSchemaBuilder<Exclude<keyof ConcretePrismaSchemaBuilder, Method>>\n>;\n\n/**\n * The brain of this whole operation: depending on the key of the method name\n * we receive, filter the available list of method calls the user can make to\n * prevent them from making invalid calls, such as builder.datasource().field()\n * */\ntype PrismaSchemaBuilder<K extends keyof ConcretePrismaSchemaBuilder> = {\n  [U in K]: U extends ExtractKeys\n    ? ConcretePrismaSchemaBuilder[U]\n    : U extends NeutralKeys\n    ? ConcretePrismaSchemaBuilder[U] //ReplaceReturnType<ConcretePrismaSchemaBuilder[U], PrismaSchemaBuilder<K>>\n    : U extends 'datasource'\n    ? PrismaSchemaSubset<U, 'datasource' | EnumKeys | FieldKeys | ModelKeys>\n    : U extends 'generator'\n    ? PrismaSchemaSubset<U, EnumKeys | FieldKeys | ModelKeys>\n    : U extends 'model'\n    ? PrismaSchemaSubset<U, DatasourceOrGeneratorKeys | EnumKeys | FieldKeys>\n    : U extends 'field'\n    ? PrismaSchemaSubset<U, DatasourceOrGeneratorKeys | EnumKeys>\n    : U extends 'enum'\n    ? PrismaSchemaSubset<U, DatasourceOrGeneratorKeys | ModelKeys | FieldKeys>\n    : PrismaSchemaSubset<\n        U,\n        DatasourceOrGeneratorKeys | EnumKeys | FieldKeys | ModelKeys | 'comment'\n      >;\n};\n\ntype Arg =\n  | string\n  | {\n      name: string;\n      function?: Arg[];\n    };\ntype Parent = schema.Block | undefined;\ntype Subject = schema.Block | schema.Field | undefined;\n\nexport class ConcretePrismaSchemaBuilder {\n  private schema: schema.Schema;\n  private _subject: Subject;\n  private _parent: Parent;\n\n  constructor(source = '') {\n    this.schema = schema.getSchema(source);\n  }\n\n  /** Prints the schema out as a source string */\n  print(options: PrintOptions = {}): string {\n    return printSchema(this.schema, options);\n  }\n\n  /** Returns the underlying schema object for more advanced use cases. */\n  getSchema(): schema.Schema {\n    return this.schema;\n  }\n\n  /** Adds or updates a generator block based on the name. */\n  generator(name: string, provider: string): this {\n    const generator: schema.Generator = this.schema.list.reduce<\n      schema.Generator\n    >(\n      (memo, block) =>\n        block.type === 'generator' && block.name === name ? block : memo,\n      {\n        type: 'generator',\n        name,\n        assignments: [\n          { type: 'assignment', key: 'provider', value: `\"${provider}\"` },\n        ],\n      }\n    );\n\n    this.schema.list.push(generator);\n    this._subject = generator;\n    return this;\n  }\n\n  drop(name: string): this {\n    const index = this.schema.list.findIndex(\n      block => 'name' in block && block.name === name\n    );\n    this.schema.list.splice(index, 1);\n    return this;\n  }\n\n  /** Sets the datasource for the schema. */\n  datasource(provider: string, url: string | { env: string }): this {\n    const datasource: schema.Datasource = {\n      type: 'datasource',\n      name: 'db',\n      assignments: [\n        {\n          type: 'assignment',\n          key: 'url',\n          value:\n            typeof url === 'string'\n              ? `\"${url}\"`\n              : { type: 'function', name: 'env', params: [`\"${url.env}\"`] },\n        },\n        { type: 'assignment', key: 'provider', value: provider },\n      ],\n    };\n    const existingIndex = this.schema.list.findIndex(\n      block => block.type === 'datasource'\n    );\n    this.schema.list.splice(\n      existingIndex,\n      existingIndex !== -1 ? 1 : 0,\n      datasource\n    );\n    this._subject = datasource;\n    return this;\n  }\n\n  /** Adds or updates a model based on the name. Can be chained with .field() or .modelAttribute() to add to it. */\n  model(name: string): this {\n    const model: schema.Model = { type: 'model', name, properties: [] };\n    this.schema.list.push(model);\n    this._subject = model;\n    return this;\n  }\n\n  /** Adds or updates an enum based on the name. Can be chained with .enumerator() to add a value to it. */\n  enum(name: string, enumeratorNames: string[] = []): this {\n    const e: schema.Enum = {\n      type: 'enum',\n      name,\n      enumerators: enumeratorNames.map(name => ({ type: 'enumerator', name })),\n    };\n    this.schema.list.push(e);\n    this._subject = e;\n    return this;\n  }\n\n  enumerator(value: string): this {\n    const subject = this.getSubject<schema.Enum>();\n    if (!subject || !('type' in subject) || subject.type !== 'enum') {\n      throw new Error('Subject must be a prisma model!');\n    }\n\n    subject.enumerators.push({ type: 'enumerator', name: value });\n    return this;\n  }\n\n  /**\n   * Returns the current subject, such as a model, field, or enum.\n   * @example\n   * builder.getModel('User').field('firstName').getSubject() // the firstName field\n   * */\n  private getSubject<S extends Subject>(): S {\n    return this._subject as S;\n  }\n\n  /** Returns the parent of the current subject when in a nested context. The parent of a field is its model. */\n  private getParent<S extends Parent = schema.Model>(): S {\n    return this._parent as S;\n  }\n\n  /**\n   * Adds a block-level attribute to the current model.\n   * @example\n   * builder.model('Project')\n   *   .blockAttribute(\"map\", \"projects\")\n   *   .blockAttribute(\"unique\", [\"firstName\", \"lastName\"]) // @@unique([firstName, lastName])\n   * */\n  blockAttribute(\n    name: string,\n    args?: string | string[] | Record<string, schema.Value>\n  ): this {\n    let subject = this.getSubject<schema.Model>();\n    if (!subject || !('type' in subject) || subject.type !== 'model') {\n      const parent = this.getParent<schema.Model>();\n      if (!parent || !('type' in parent) || parent.type !== 'model')\n        throw new Error('Subject must be a prisma model!');\n\n      subject = this._subject = parent;\n    }\n\n    const attributeArgs = ((): schema.AttributeArgument[] => {\n      if (!args) return [] as schema.AttributeArgument[];\n      if (typeof args === 'string')\n        return [{ type: 'attributeArgument', value: `\"${args}\"` }];\n      if (Array.isArray(args))\n        return [{ type: 'attributeArgument', value: { type: 'array', args } }];\n      return Object.entries(args).map(([key, value]) => ({\n        type: 'attributeArgument',\n        value: { type: 'keyValue', key, value },\n      }));\n    })();\n\n    const property: schema.ModelAttribute = {\n      type: 'attribute',\n      kind: 'model',\n      name,\n      args: attributeArgs,\n    };\n    subject.properties.push(property);\n    return this;\n  }\n\n  /** Adds an attribute to the current field. */\n  attribute<T extends schema.Field>(\n    name: string,\n    args?: Arg[] | Record<string, string[]>\n  ): this {\n    const parent = this.getParent();\n    const subject = this.getSubject<T>();\n    if (!parent || !('type' in parent) || parent.type !== 'model') {\n      throw new Error('Parent must be a prisma model!');\n    }\n\n    if (!subject || !('type' in subject) || subject.type !== 'field') {\n      throw new Error('Subject must be a prisma field!');\n    }\n\n    if (!subject.attributes) subject.attributes = [];\n    const attribute = subject.attributes.reduce<schema.Attribute>(\n      (memo, attr) =>\n        attr.type === 'attribute' && attr.name === name ? attr : memo,\n      {\n        type: 'attribute',\n        kind: 'field',\n        name,\n      }\n    );\n\n    if (Array.isArray(args)) {\n      const mapArg = (arg: Arg): schema.Value | schema.Func => {\n        return typeof arg === 'string'\n          ? arg\n          : {\n              type: 'function',\n              name: arg.name,\n              params: arg.function?.map(mapArg) ?? [],\n            };\n      };\n\n      if (args.length > 0)\n        attribute.args = args.map(arg => ({\n          type: 'attributeArgument',\n          value: mapArg(arg),\n        }));\n    } else if (typeof args === 'object') {\n      attribute.args = Object.entries(args).map(([key, value]) => ({\n        type: 'attributeArgument',\n        value: { type: 'keyValue', key, value: { type: 'array', args: value } },\n      }));\n    }\n\n    if (!subject.attributes.includes(attribute))\n      subject.attributes.push(attribute);\n\n    return this;\n  }\n\n  /** Add an assignment to a generator or datasource */\n  assignment<T extends schema.Generator | schema.Datasource>(\n    key: string,\n    value: string\n  ): this {\n    const subject = this.getSubject<T>();\n    if (\n      !subject ||\n      !('type' in subject) ||\n      !['generator', 'datasource'].includes(subject.type)\n    )\n      throw new Error('Subject must be a prisma generator or datasource!');\n\n    function tap<T>(subject: T, callback: (s: T) => void) {\n      callback(subject);\n      return subject;\n    }\n\n    const assignment = subject.assignments.reduce<schema.Assignment>(\n      (memo, assignment) =>\n        assignment.type === 'assignment' && assignment.key === key\n          ? tap(assignment, a => {\n              a.value = `\"${value}\"`;\n            })\n          : memo,\n      {\n        type: 'assignment',\n        key,\n        value: `\"${value}\"`,\n      }\n    );\n\n    if (!subject.assignments.includes(assignment))\n      subject.assignments.push(assignment);\n\n    return this;\n  }\n\n  private blockInsert(statement: schema.Break | schema.Comment): this {\n    let subject = this.getSubject<schema.Block>();\n    const allowed = ['datasource', 'enum', 'generator', 'model'];\n    if (!subject || !('type' in subject) || !allowed.includes(subject.type)) {\n      const parent = this.getParent<schema.Block>();\n      if (!parent || !('type' in parent) || !allowed.includes(parent.type)) {\n        throw new Error('Subject must be a prisma block!');\n      }\n\n      subject = this._subject = parent;\n    }\n\n    switch (subject.type) {\n      case 'datasource': {\n        subject.assignments.push(statement);\n        break;\n      }\n      case 'enum': {\n        subject.enumerators.push(statement);\n        break;\n      }\n      case 'generator': {\n        subject.assignments.push(statement);\n        break;\n      }\n      case 'model': {\n        subject.properties.push(statement);\n        break;\n      }\n    }\n    return this;\n  }\n\n  /** Add a line break */\n  break(): this {\n    const lineBreak: schema.Break = { type: 'break' };\n    return this.blockInsert(lineBreak);\n  }\n\n  /**\n   * Add a comment. Regular comments start with // and do not appear in the\n   * prisma AST. Node comments start with /// and will appear in the AST,\n   * affixed to the node that follows the comment.\n   * */\n  comment(text: string, node = false): this {\n    const comment: schema.Comment = {\n      type: 'comment',\n      text: `//${node ? '/' : ''} ${text}`,\n    };\n    return this.blockInsert(comment);\n  }\n\n  /**\n   * Add a comment to the schema. Regular comments start with // and do not appear in the\n   * prisma AST. Node comments start with /// and will appear in the AST,\n   * affixed to the node that follows the comment.\n   * */\n  schemaComment(text: string, node = false): this {\n    const comment: schema.Comment = {\n      type: 'comment',\n      text: `//${node ? '/' : ''} ${text}`,\n    };\n    this.schema.list.push(comment);\n    return this;\n  }\n\n  /** Add a field to the current model. The field can be customized further with one or more .attribute() calls. */\n  field(name: string, fieldType: string | schema.Func): this {\n    let subject = this.getSubject<schema.Model>();\n    if (!subject || !('type' in subject) || subject.type !== 'model') {\n      const parent = this.getParent<schema.Model>();\n      if (!parent || !('type' in parent) || parent.type !== 'model')\n        throw new Error('Subject must be a prisma model!');\n\n      subject = this._subject = parent;\n    }\n\n    const field: schema.Field = {\n      type: 'field',\n      name,\n      fieldType,\n    };\n    subject.properties.push(field);\n    this._parent = subject;\n    this._subject = field;\n    return this;\n  }\n\n  /**\n   * Returns the current subject, allowing for more advanced ways of\n   * manipulating the schema.\n   * */\n  then<R extends schema.Block>(callback: (subject: R) => R): this {\n    callback(this._subject as R);\n    return this;\n  }\n}\n\nexport function createPrismaSchemaBuilder(\n  source?: string\n): PrismaSchemaBuilder<\n  Exclude<\n    keyof ConcretePrismaSchemaBuilder,\n    DatasourceOrGeneratorKeys | EnumKeys | FieldKeys | ModelKeys\n  >\n> {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return new ConcretePrismaSchemaBuilder(source) as any;\n}\n"],"names":["Identifier","createToken","name","pattern","Datasource","push_mode","Generator","Model","Enum","True","longer_alt","False","Null","Comment","Lexer","NA","DocComment","categories","LineComment","Attribute","ModelAttribute","label","FieldAttribute","Dot","QuestionMark","LCurly","RCurly","pop_mode","LRound","RRound","LSquare","RSquare","Comma","Colon","Equals","StringLiteral","NumberLiteral","WhiteSpace","group","SKIPPED","LineBreak","line_breaks","naTokens","multiModeTokens","modes","global","block","defaultMode","PrismaLexer","parser","lexer","_this","RULE","CONSUME1","CONSUME2","CONSUME","LABEL","SUBRULE","value","MANY_SEP","SEP","DEF","OR","ALT","keyedArg","array","func","OPTION1","MANY","attribute","OPTION2","options","componentType","isEnum","isModel","comment","GATE","property","field","assignment","OPTION","OR1","OR2","attributeArg","type","ARGS","image","component","performSelfAnalysis","CstParser","PrismaVisitor","validateVisitor","schema","ctx","list","map","item","_this2","visit","componentName","this","assignments","properties","enumerators","Error","text","_ctx$list2","_this3","assignmentValue","key","assignmentName","fieldType","fieldName","attributes","attributeList","_this4","_ctx$comment","_ctx$comment$","optional","attributeName","groupName","args","attr","_this5","kind","modelAttribute","funcName","params","_this6","keyedParams","_this7","keyName","enumName","_ctx$comment2","_ctx$comment2$","getBaseCstVisitorConstructorWithDefaults","getSchema","source","lexingResult","tokenize","input","tokens","cstNode","errors","length","unsorted","defaultSortOrder","printSchema","sort","locales","undefined","sortOrder","blocks","filter","sorter","a","b","indexOf","concat","typeIndex","localeCompare","schemaSorter","printBlock","Boolean","join","EOL","replace","printComment","children","computeAssignmentFormatting","db","enumerator","printEnumerator","printEnum","generator","printGenerator","model","pos","listBlocks","nameLengths","typeLengths","reduce","memo","current","index","arr","push","lists","max","Math","printFieldType","prop","shift","node","nameLength","typeLength","printAttribute","padEnd","attrs","trim","printField","printBreak","printProperty","printModel","printAttributeArg","unshift","arg","printValue","suffix","printFunction","String","keyLengths","keyLength","printAssignment","ConcretePrismaSchemaBuilder","print","provider","_subject","drop","findIndex","splice","datasource","url","env","existingIndex","enumeratorNames","e","subject","getSubject","getParent","_parent","blockAttribute","parent","attributeArgs","Array","isArray","Object","entries","mapArg","_arg$function","includes","callback","tap","blockInsert","statement","allowed","schemaComment","then"],"mappings":"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"}